s = 'hiterr'

print(s[-1])
print(s[:-3])

print()
q = '1234567890987654321'
print(q[3:-2:2])  # start:end:步长

print(q.index('4',1, -1)) #q[3]=4



# Python 的解释器在处理缺失值（也就是你空着不写的地方）时，遵循一套严格的默认规则。这套规则的核心在于：“步长（Step）的正负决定了起点和终点的默认值”。

# 我们可以把切片标准式写为 [start : stop : step]。

# 当某些数没写时，Python 会在后台自动填入 None，然后根据 step 将其转化为具体的整数。

# 以下是所有情况的严谨映射表：

# 1. 只有一个冒号 [a : b]
# 前提： 当你只写一个冒号时，step 默认为 +1。

# 写法,缺失项,实际填充值 (Math),含义
# ls[:],"Start, Stop",[0 : len : 1],全拷贝。从头取到尾。
# ls[a:],Stop,[a : len : 1],从 a 开始，一直取到最后。
# ls[:b],Start,[0 : b : 1],从 0 开始，一直取到 b (不含)。

# 2. 有两个冒号 [a : b : c]
# 这里的情况取决于 c 是正数还是负数。这是最关键的分水岭。

# 情况 A：步长是正数 (c > 0)
# 逻辑： 从左向右走。

# Start 默认值： 0 (列表头部)

# Stop 默认值： len (列表尾部之后)

# 写法,缺失项,实际填充值,"例子 ls = [0,1,2,3,4,5]"
# ls[::2],"Start, Stop",[0 : len : 2],"[0, 2, 4] (从头到尾，隔一个取一个)"
# ls[2::2],Stop,[2 : len : 2],"[2, 4] (从下标2开始往右走)"
# ls[:4:2],Start,[0 : 4 : 2],"[0, 2] (从头开始走到下标4)"

# 情况 B：步长是负数 (c < 0)
# 逻辑： 从右向左走（倒车）。

# Start 默认值： len - 1 (列表最后一个元素)（依然是闭区间）

# Stop 默认值： -∞ (理论上是 -1 甚至更小，代表穿过下标0)(依然是开区间，如果写了数的话)
              
# 写法,缺失项,实际填充值,"例子 ls = [0,1,2,3,4,5]"
# ls[::-1],"Start, Stop",[last : -∞ : -1],"[5, 4, 3, 2, 1, 0] (经典倒序)"
# ls[3::-1],Stop,[3 : -∞ : -1],"[3, 2, 1, 0] (从下标3开始，一直往左走到头)"
# ls[:2:-1],Start,[last : 2 : -1],"[5, 4, 3] (从最后开始往左走，走到下标2停)"


# 如果有数没写，意思就是“走到尽头”。哪边是尽头？看步长方向！步长为正 ($+$)：起点的尽头是开头，终点的尽头是末尾。步长为负 ($-$)：起点的尽头是末尾，终点的尽头是开头。
                                                                 
#  4. 示例
#  ls[::]等同于 ls[:]，也等同于 ls[0 : len : 1]。含义：普通的浅拷贝。ls[ : : -1] (全空，只有步长是负)Start 缺省 $\to$ 变成“最后一个元素”。Stop 缺省 $\to$ 变成“包含第一个元素”。含义：倒叙全拷贝。ls[ : -2 : -1] (Start 缺省，Stop=-2, Step=-1)Start 缺省 $\to$ 因为是负步长，自动填为“最后一个元素”。含义：从最后一个元素开始倒着走，一直走到倒数第二个元素（不含）。例如 [0, 1, 2, 3] $\to$ 结果是 [3] (取下标 3，停在下标 2)。